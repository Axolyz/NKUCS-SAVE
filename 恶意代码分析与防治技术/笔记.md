# 考核占比

* 期末考试70%
* 平时成绩30%
  * 实验报告（学堂在线提交）
  * 上课考勤（雨课堂）
  * 课后练习（随堂）

# 第1章 计算机病毒分析概论

## 1.1 计算机病毒的定义和类型

### 定义

感染的目标从原本的主机、服务器，扩展到所有的联网设备

**定义**：编制或者在计算机程序中插入的破坏计算机功能或者毁坏数据，影响计算机使用，并且能自我复制的一组计算机指令或者程序代码

更广义的定义：<u>恶意代码</u>，包括蠕虫、木马、rootkit、勒索病毒等

### 功能分类

* 后门（back door）：攻击者能绕开安全认证，远程控制受感染的计算机
* 僵尸网络：由大量被感染的计算机组成的网络，可以发起大规模的网络攻击，例如DDoS攻击
* 木马：表面是有用软件，但隐藏有恶意代码
* 下载器、启动器：用于下载和执行其他病毒的恶意代码
* 间谍软件：收集信息并发送给攻击者的恶意代码
* rootkit：获取计算机root权限的工具，可以用来==隐藏其他病毒==
* 勒索软件：通过加密受感染的文件或者硬盘，索要赎金的病毒
* 垃圾邮件发送病毒：使用系统和网络资源来发送大量的垃圾邮件，例如广告邮件、钓鱼邮件等
* 蠕虫：自我复制并感染其他计算机

目前，同一个病毒经常会包括其他的多个类型功能

### 目标分类

* 大众型的计算机病毒：比如勒索软件，采用的是一种撒网捞鱼的方法，设计目标就是要感染尽可能多的机器，这类恶意代码是比较普遍的，恶意行为也比较明显，容易被检测和防御
* 针对型的计算机病毒：针对特定组织而研制的，样本收集难度大，一般不会广泛传播，并且样本分析难度大、代码复杂

## 1.2 计算机病毒分析的目标

### 计算机病毒分析

> 通常是为一起计算机病毒事件的应急响应提供所需信息，包括以下分析内容

* 系统到底发生了什么
* 定位被感染的计算机和可疑的程序
* 对可疑文件进行分析
* 提取出可以在系统和网络上检测病毒的特征码
* 衡量并消除计算机病毒所带来的的损害

要知道工作原理 - 识别病毒 - 消除病毒

### 计算机病毒特征码

> 特征码可以用于查杀系统中的病毒文件、拦截病毒网络传播

#### 主机特征码

> 主机行为的匹配

e.g. 注册表的特定修改、创建或者修改了特定的文件等

**主机特征码和反病毒软件所使用的的病毒特征码不同**，主机特征码关注的是病毒对系统做了什么，关注的是**行为**，而不是病毒本身代码的特征

通常主机特征码比反病毒软件特征码更加有效，反病毒软件特征码容易遇见：多态、变形、加壳、花指令等等的影响；亦或者是病毒执行的过程中，甚至会将自身从硬盘中删除，只保留内存中的映像，如此杀毒软件就没用了

#### 网络特征码

> 网络数据包的匹配

e.g. 僵尸网络的通信数据包、与恶意IP地址的连接等

网络特征码包括：

* 恶意的IP地址
* URL
* 邮件
* 攻击数据包
* 计算机病毒间的通信协议
* ……

可以和主机特征码相结合，提供更高的检测率和更少的误报率

## 1.3 计算机病毒分析技术概述

### 静态分析

> 指在没有运行计算机病毒时，对其分析的相关技术

常用工具有：VirusTotal、strings、IDA pro等

通过**反汇编**去看病毒文件的指令特征

#### 静态基础分析技术

> 分析可执行文件，但不查看具体CPU指令的分析技术

* 常用工具有：VirusTotal、strings等

非常快速、简单，但是面对复杂的病毒，可能会漏掉一些重要行为

#### 静态高级分析技术

> 对计算机病毒内部机制的逆向工程,通过将可执行文件装载到反汇编器中,查看程序CPU指令,来分析病毒到底做了什么。

* 深入分析计算机病毒。
* 需要掌握汇编语言、Windows系统编程等知识。
* 易受代码混淆技术的干扰,例如加壳、花指令等。

### 动态分析

> 需要运行病毒，实际监测

常用工具有：RegShot、Process Monitor、OllyDbg等

#### 动态基础分析技术

> 通过运行病毒，分析病毒在系统和网络上的行为，提取病毒的特征码

需要建立安全分析环境

安全、简单，也会漏掉一些重要的病毒功能

#### 动态高级分析技术

* 使用调试器来分析一个病毒运行时刻的内部状态。
* 动态执行每一条指令,验证静态高级分析的结果。
* 可以缓解代码混淆的干扰。
* 只能覆盖一条计算机病毒的执行轨迹。

### 分析经验

* 不要过于陷入细节，要关注主要功能。在进入细节分析之前要有一个概要性的理解（即要知道病毒的行为到底是做了什么，要有方向的分析）
* 尝试从不同角度、用不同工具和方法来分析病毒
* 病毒也是在不断的编译和进化，应该快速的应对病毒的新变化 



# 第2章 静态基础分析技术

* 计算机病毒没有被执行（以文件形式存在）

* 没有分析计算机病毒的CPU指令

* 常用技术

  * 杀毒软件

  * 哈希值

  * 文件特征分析

    * 字符串分析

    * 函数分析

    * 文件头分析

    * ###### ……

## 2.1 杀毒软件

### 病毒特征库

> 已知计算机病毒样本的特征数据库

### 启发式规则

* 是对特征库扫描技术的补充
* 在已知计算机病毒分析经验的基础上，总结出来的规则
* 可以检测到未知的计算机变种

### 面临的挑战

> 计算机病毒的编写者很容易的修改自己的代码，从而改变这些病毒的各种特征功能，来躲避杀毒软件的检测

* 垃圾指令（加入大量冗余的指令、字符串）
* 多态技术：语义不变，语法混淆（如比较某个数是否为0，可以与0相减，可以和0异或）
* 变形计数：功能不变，语义混淆
* 单向执行技术：未解数学猜想、哈希值
* 新的病毒家族：
  * 新出现的病毒家族，通常不会被这些杀毒软件识别，因为病毒特征库里面没有新的样本
  * 启发式检测也可以被新的病毒家族绕过去，因为新的病毒家族的行为与已知家族的不一样

### 多杀毒软件交叉检测

* 不同杀毒软件使用了不同特征库和启发式检测方法
* 增加病毒躲避的难度

可以用VirusTotal提交样本进行检测

## 2.2 哈希值：恶意代码指纹

哈希值：由哈希函数计算得来，是从任何一种数据中创建小的数字“指纹”的方法

* 输入：文件、任意长度的字符串
* 输出：固定长度的哈希值，MD5（128bit），SHA256（256bit）

功能：**唯一**的识别一个文件

特点：

* 很少产生碰撞
* 计算速度快，识别简单
* 易于分享给其他的病毒分析员
* 在线检测，查询是否已经有了分析结果

获得Hash值的方式：可以使用工具HashCalc，或者用python直接算

## 2.3 特征字符串

编码技术：UTF-8，Unicode，GBK，ASCII等

* **提取字符串的工具：Strings**

<u>注意</u>：Strings在搜索ASCII和Unicode字符串的时候，会忽略上下文格式，可能一个字符串搜出来的是内存地址、CPU指令序列或者是一段数据等等。<u>搜索三个或者三个以上连续的ASCII或Unicode字符，并以终结符结尾</u>

Strings执行实例：

![image-20210906102658303](.\img\image-20210906102658303.png)

==通常在使用的时候，会将文件后缀改成非exe，防止进行误操作导致病毒执行==

## 2.4 加壳与混淆

* 目的

> 使计算机病毒更难检测和分析

* 混淆

> 隐藏计算机病毒程序的信息

* 加壳

> 压缩计算机病毒文件大小，并可以进行加密

正常来说Strings的指令是能搜索出很多的字符串的，但是在加壳之后，能搜索出来的字符串就相对较少，<u>缺少对分析有用的字符串</u>。

* 加壳和混淆后文件的对比

![image-20210906103150723](.\img\image-20210906103150723.png)

左边为原始，右边为加壳、压缩后

加壳程序在执行时，需要进行动态的脱壳

* **UPX加壳工具**

![image-20210906103538305](.\img\image-20210906103538305.png)

如图是使用strings工具对加壳前后进行一个检测

1. 第一个数字，表示字符串的数量。

   可以发现字符串数量不减反增，其原因在于无效字符串增加了，很多的字符串是那种很短但是没有意义的字符串；像URL、地址IP信息等都是比较长的，但是经过加壳之后，很多可能会出现有截断等等，也就是说经过了加壳以后，以前的较长的字符串被“截断”了。

2. 第二个数字，表示单词或者说字符的数量

   此时单词的数量变化不大，但是



* **PEiD检测壳信息**

> 一个工具，收集了各种加壳工具形成的壳的信息

![image-20210906104058381](.\img\image-20210906104058381.png)

==注意==：PEiD有可能会使得==病毒执行==。原因：这个工具有一个缓冲区溢出的漏洞，病毒编写者可能会利用这个漏洞，使得病毒被执行

## 2.5 PE文件格式

> Windows可执行程序（exe）和动态链接库都是使用的PE文件格式
>
> PE文件格式中包含Windows如何将文件从硬盘加载到内存中执行的必要信息

### PE文件头

1. 可执行代码信息
2. 程序的类型，exe、dll
3. 依赖的动态链接库
4. 需要的内存空间

**LoadPE工具**

![image-20210906104555634](.\img\image-20210906104555634.png)

### PE文件中的分节

> 使用节表对不同的数据进行标识、分节

* .text

> 包含了CPU的执行指令，所有其他节存储数据和支持性的信息。
>
> 一般来说，这是唯一可以执行的节，也是唯一包含代码的节

* .rdata

> 通常包含导入导出函数信息，这个节中还可以存储程序所使用的其他只读数据

* .data

> 包含了程序的全局数据，并且是可读写的

* .rsrc

> 包含由可执行文件所使用的资源，而这些内容并不是可执行的，比如：图标、图片、菜单项和字符串

有的时候计算机病毒会使用这个节去存储其他的病毒，例如装载器

* **PEview工具**

> 是一个二进制可执行代码的分析工具，可以看见文件头等信息

![image-20210906105224561](.\img\image-20210906105224561.png)

* **Resource Hacker**工具

> 可以使用这个工具来查看.rsrc资源节。
>
> 单击工具中分析获得条目时，可以看见字符串、图标、菜单等

![image-20210906105417011](.\img\image-20210906105417011.png)

## 2.6 链接库与函数

### 引入表

> 计算机病毒代码会调用动态链接库中的函数，通过链接将计算机病毒代码与动态链接库连接在一起

#### 链接方法

根据链接时间的不同，链接方法有如下分类：

* 静态链接（Windows不常用，在UNIX和Linux程序中比较常见）
  * 当一个库被静态链接到可执行程序时，所有这个库中的代码都会复制到可执行程序中去。PE文件头里没有链接库的信息（也就相当于说是，直接把所有的头文件中的代码都相当于是自己写的代码，全都整合在一起，此时也就没有那种引用的概念了）
  * 可执行程序体积大
  * 占用内存空间 

* 运行时链接（在合法程序中不流行，但是恶意代码中常用，尤其是在加壳或者混淆的时候）

  * 只有当需要使用函数时，才会链接到库
  * 最常用的函数
    * LoadLibrary：将动态链接库动态的从硬盘加载到病毒的内存空间
    * GetProcAddress：从动态链接库中找到对应函数的调用地址

* 动态链接（最常见的）

  > 当代码库被动态链接的时候，宿主操作系统会在程序被装载时搜索需要用到的代码库；如果程序调用了被链接的函数，这个函数会在**代码库**中执行

#### 基于链接的分析

* PE文件头列出了计算机病毒代码所需要的所有动态链接库和函数

  动态链接库和函数名字可以用来分析计算机病毒的功能：

  * URLDownloadToFile() 提示计算机病毒会从Internet上下载一个文件

* **Dependecy Walker**工具

  包含在Visual Studio的一些版本与其他微软开发包中，支持列出可执行文件的动态链接库

![image-20210906142313452](.\img\image-20210906142313452.png)

1. 左上角表示引入的动态链接库名称
2. ③的位置列出了引入的所有函数名
3. ④的位置列出了动态链接库所有函数名
4. ⑤列出的是系统中其他动态链接库的信息

### 常用的动态链接库

* Kernel32.dll
  * 包括Windows的核心功能，如访问文件、内存、硬件等
* Advapi32.dll
  * 提供了对高级的Windows对象的访问，如注册表、服务管理器等
  * 需要病毒自启动或者提供服务等时候会使用到这个动态链接库
* User32.dll
  * 提供了用户的接口对象，如鼠标滚动、菜单等
  * 一般在需要监控用户行为时会使用
* Gdi32.dll
  * 显示和操作图像的功能
* Ntdll.dll
  * 底层的动态链接库
  * 被Kernel32.dll引用
* WSock32.dll 和 Ws2_32.dll
  * 用来操作socket编程，一般需要操作网络链接时使用
  * 提供了底层网络访问的功能，如tcp、ip等
* Wininet.dll
  * 提供了更高层的网络访问功能，如http、ntp等应用层的网络功能

### 导入函数

> PE文件头中也包含了可执行文件使用的特定函数相关信息

加壳程序的导入函数和动态链接库是很少的，一般就只有Kernel32 和 User32

### 导出函数

> 用来和其他程序、代码进行交互时所使用的，通常一个DLL会实现一个或者多个功能函数，然后把它们导出，使得其他程序能够使用这些函数

常用的导出函数：

![image-20210906144700552](.\img\image-20210906144700552.png)



# 第3章 虚拟机

## 3.1 虚拟机的结构

动态分析：监控病毒的行为

需要阻断病毒与Internet和其他电脑的链接

**隔离的物理机器**

* 缺点
  * 没有网络链接，部分行为不会展现
  * 有些病毒难以从系统中清除，分析之后需要给机器重装系统
* 优点
  * 有些优点会探测执行环境，在虚拟机中是不能正常执行的

==虚拟机存在漏洞，有些病毒会从虚拟机中逃逸，进行感染==

## 3.2 创建虚拟机

win XP依旧是目前最流行的病毒分析环境，Windows系统是向下兼容的

* 网络配置
  * 桥接模式(bridge)
    * 虚拟网卡
    * 允许虚拟机与物理机一样连接到相同的物理网络
  * NAT模式
    * 网络地址转换模式，共享主机与互联网之间的IP连接
    * 宿主机像是一个路由器，负责对所有来自虚拟机的连接进行翻译，让他们看起来像是从宿主机的IP地址出发一样
    * 虚拟机和物理机共用一个IP地址
    * 还有一种理解：虚拟机使用物理机中的一个端口将信息传递给物理机，然后物理机通过IP进行转发
  * 主机模式
    * 创建一个隔离的私有局域网
    * 私有局域网不会连接到互联网，将计算机病毒与Internet隔离，同时也允许某些网络连接

## 3.3 使用虚拟机

**快照**，利用快照恢复到以前的状态

要记得断开外围设备，防止USB病毒会感染连接的USB设备



# 第4章 动态分析基础

## 4.1 沙箱分析

沙箱包含一个虚拟环境，模拟服务，确保测试的软件能正常执行，并进行基本的动态分析和监控、生成报告

**沙箱的挑战**

* 沙箱只能简单的运行可执行程序，不能带有命令行选项
* 沙箱也不能记录所有事件，不会等待足够长的时间让所有事件都发生
* 恶意代码可能会检测是否在一个虚拟机中运行，如果检测到了虚拟机，恶意代码可能会停止运行或者表现异常
* 一些恶意代码需要系统上有特定的注册表项或者文件才能执行，但是沙箱不具备这样的环境
* 如果恶意代码是DLL，一些导出函数可能不会被恰当的调用

## 4.2 运行病毒和进程监视

### DLL格式文件的运行

在所有的Windows版本中都包含有rundll32.exe这个程序，他提供了一个运行DLL的平台，语法为：`rundll32.exe DLLname, Eport arguments`，其中Export值必须是一个DLL文件导出函数表中的函数名或者序号（可以使用Dependency Walker、PE View、PE Explorer查看导出函数列表）

DLL形式的计算机病毒也可能需要被安装成一个服务：

在ipr32x.dll中导出了InstallService函数，ServiceName参数必须提供给计算机病毒，让她能够被安装并运行起来。而在Windows中启动指定的服务，可以使用`net start`命令

e.g. `rundll32 ipr32x.dll,InstallService ServiceName`

​        `net start SeviceName`

* 进程监视器(Process Monitor)

  Windows下的一个高级监视工具，提供一种方式监控注册表、文件系统、网络、进程和线程行为

  结合并增强了两种工具的功能：文件监视器FileMon和注册表监视器RegMOn

  ![image-20210926152025140](.\img\image-20210926152025140.png)

## 4.3 Process Explorer和Regshot

### Process Explorer

一个**任务管理器**，动态分析的必备工具，他的功能有：

* 列出所有活跃的进程
* 被进程载入的DLL
* 各种进程属性和系统信息
* 杀死一个进程、退出用户登录、启动与激活进程

![image-20210926152234234](.\img\image-20210926152234234.png)

不同的颜色分区表示不同类型的进程：

* 粉色：服务进程
* 蓝色：普通进程
* 绿色：新创建的进程（临时的高亮显示）
* 红色：已经被终止的进程（临时的高亮显示）

![image-20210926152455531](.\img\image-20210926152455531.png)

![image-20210926152553706](.\img\image-20210926152553706.png)

![image-20210926152558518](.\img\image-20210926152558518.png)

![image-20210926152629989](.\img\image-20210926152629989.png)

* 镜像标签里的验证，可以验证磁盘上的镜像文件是否具有微软的签名认证（如果某个文件被病毒感染，会导致签名认证失败，由此可以提醒分析员这个文件存在有问题）
* 进程替换技术：看起来就像一个合法执行的进程，但是在内存中的镜像会和磁盘上的不一样
* 验证按钮验证的是磁盘上的镜像文件，而不是内存中的

#### 检查是否存在进程替换的技术

##### 比较字符串

一种识别进程替换的方法就是进程属性窗口的字符串（strings）标签，通过比价磁盘文件的字符串与内存的字符串，来看两者是否相同

* 如果字符串列表有很大不同，那么可能发生了进程替换
  * 字符串FAVORITES.DAT多次出现在内存中镜像，但在磁盘上无法找到

![image-20210926153525698](.\img\image-20210926153525698.png)

##### DLL比较

* Process Explorer可以查看进程运行中，内存空间装载了哪些DLL

* Dependency Walker可以通过分析文件的PE结构，列出文件所需要装载的DLL

通过对比内存和硬盘上DLL列表的不同，可以发现DLL注入、进程替换

##### 恶意文档分析

* 一种快速确定一个文档是否恶意的方法，就是打开进程浏览器，然后打开文档
* Process Explorer可以监控文档是否创建了新的进程
* 通过属性窗口中的镜像（Image）标签来定位恶意代码在硬盘上的位置

### RegShot

* 一个开源的注册表快照比较工具
* 对不同时间的注册表进行快照
* 比较两个注册表的快照，发现差异

![image-20210926154231341](.\img\image-20210926154231341.png)



## 4.4 网络模拟

>  计算机病毒会经常连接到命令与控制服务器，所以需要采用一些模拟网络的基本技术，用来快速模拟网络资源，而不需要实际地连接互联网。这些资源包括：DNS域名系统、IP地址和数据包记录器。

**ApateDNS工具**

在本机上通过监听UDP的53端口，对用户指定的IP地址做出虚假的DNS相应。

用指定的IP地址去相应DNS查询请求。ApateDNS可以使用十六进制和ASCII码来显示所有接收到的请求

**Netcat工具**

> 被称为“TCP/IP协议栈瑞士军刀”

支持端口扫描、隧道、代理、端口转发等

在监听模式下，Netcat充当一个服务器，而在连接模式下作为一个客户端。Netcat从标准输入得到数据进行网络传输，通过标准输出显示到屏幕上

假设病毒访问的是80端口，在执行恶意代码之前，使用Netcat监听连接

![image-20210926155546507](.\img\image-20210926155546507.png)

Netcat命令：

* -l 选项的意思是监听
* -p 选项指明了监听端口

**Wireshark工具**

进行数据包监听的工具

![image-20210926155832219](.\img\image-20210926155832219.png)

**INetSim工具（Linux）**

![image-20210926155916488](.\img\image-20210926155916488.png)

![image-20210926160008799](.\img\image-20210926160008799.png)

如果没有启用INetSim工具，那么此时会返回404；如果启动的这个工具，会返回一个数据包

使用INetSim甚至能欺骗NMAP扫描器

![image-20210926160202553](.\img\image-20210926160202553.png)

* INetSim几乎能提供所有的文件请求服务
* INetSim可以记录所有的连入请求与连接
  * 使用端口号的修改、是否连接到一个标准服务、设置请求后返回一个页面或者一个项目
* INetSim的Dummy服务可以记录病毒连接的所有端口和发送数据

![image-20210926160410455](.\img\image-20210926160410455.png)

# 第5章
## 5.1 逆向工程
### 计算机体系的抽象层次
* 硬件
  * 硬件是唯一一个物理层，由电子电路组成
  * XOR门、AND门、NOT门等逻辑器件
  * 由于物理特性，硬件很难被软件操作
* 微指令
  * 又称为固件
  * 微指令只能在为他设计的电路上执行，这层由一些微指令构成，他们是从更高级的机器码层翻译而来，提供了访问硬件的接口。
  * 病毒分析时也不会关心这种为特定的计算机硬件设计的微指令
* 机器码
  * 由操作码组成
    * 操作码就是一些十六进制的数字，告诉机器需要做什么
  * 机器码一般是多条微指令实现，这样硬件就能执行代码了。
  * 而机器码本身是由高级语言编写的程序翻译而来
* 低级语言
  * 主要指汇编
  * 利用反汇编器生成低级语言的文本，这些文本会由助记符等组成，如mov和jmp。
* 高级语言
* 解释型语言
  * 如C#，Perl，NET，Java等语言
  * ==这一层的代码不会被编译成机器码，而是被翻译成了字节码==，但是在执行的时候还是以机器码执行

**不同的CPU，汇编指令是不一致的**
如：x86-32 bit Intel是最常用的指令集,x64-64 bit Intel，SPARC,PowerPC,MIPS,ARM等；windows和Linux运行在x86 or x64指令集上

其中x64系统可以运行x86的程序

大部分计算机病毒是针对的x86指令集

## 5.2 x86体系结构
x86体系结构遵循冯·诺伊曼结构

![structure](img/2021-09-30%2012-25-08屏幕截图.png)

这种结构包含三种硬件组件：
1. 中央处理单元（CPU），负责执行代码
2. 内存（RAM），负责存储所有的数据和代码
3. 输入输出设备（I/O），为硬盘、磁盘、显示器等设备提供接口

### 内存
**根据读写权限**恶意代码的内存可以分为以下四个主要的节：
1. .data，可读可写：这个词指的是内存中的一个特定的节，为数据节，其中包含了全局变量、字符串等数据
2. .text，可执行可读（一般可写）：被称为代码节，其中包含了在执行程序任务时CPU所取得的指令。这些代码决定了程序是做什么的，以及程序中的任务是如何协调工作的
3. heap，堆，可读可写（一般不可执行）：堆是程序执行期间需要动态内存分配的，用于创建新的值，以及消除不需要的值。被称为**动态内存**，是因为其内容在程序运行时经常被改变
4. stack，栈：用于函数的局部变量和参数，以及控制程序执行流（栈帧的切换）

### 指令
指令是汇编的构成块，表示要执行的指令。如mov表示移动数据。

### 操作码
每条指令使用操作码告诉CPU需要执行什么样的操作

### 字节序
#### 大端字节序
一个多字节组成的数据，最高位被存在内存的低地址上

如：127.0.0.1 表示为：0x7F 00 00 01

网络中的数据传输就是使用的大端字节序

#### 小端字节序
最低位被存在内存的低地址上

如：127.0.0.1 表示为：0x01 00 00 7F

x86程序中使用小端字节序

### 操作数
操作数有以下三种：
* 立即数：操作数是一个固定的值，如0x42
* 寄存器：操作数指向寄存器，如ecx
* 内存地址：操作数指向需要用的值的内存地址，一般来说由方括号内包含值、寄存器或者方程式组成，如[eax]

## 5.3 CPU寄存器
> 寄存器是可以被CPU直接访问的少量数据存储器，访问其中的内容的速度会比访问其他的存储器要快

可以吧它们归为4类：

* 通用寄存器：一般用于存储数据或者内存地址，而且经常交换着使用以完成程序。除了指令的定义，通用寄存器还被程序一致特性使用
  * EAX（累加寄存器，或者作为程序返回的变量的寄存器）
  * EBX（基址寄存器）
  * ECX（计数）
  * EDX（数据寄存器）
  * EBP（栈帧的底部）
  * ESP（栈帧的顶部）
  * ESI（源索引）
  * EDI（目标索引）
* 段寄存器
  * CS
  * SS
  * DS
  * ES
  * FS
  * GS
* 标志寄存器
  * EFLAGS：每一位都表示着一个状态
    * ZF：当一个运算结果为0时置1，反之为0
    * CF：当一个运算的结果相对于目标操作数太大或者太小的时候，CF被置1，反之为0
    * SF：当一个运算的结果为负数，SF置1，反之为0；同时要注意，当算术运算的结果的最高位是1时，SF也会被置1（认为最高位是标志位，如果标志位为1也表示负数）
    * TF：TF用于调试。当他置1时，86处理器每次只执行一条指令
* 指令指针
  * EIP：保存了程序将要执行的下一条指令在内存中的地址，EIP的唯一作用就是告诉CPU下一条要执行的指令位置在哪。

所有的通用寄存器大小都是32位，可以在汇编代码中使用32位或者是16位。其中有4个寄存器（EAX,EBX,ECX,EDX）还可以以8位的方式引用，从而使用其最低的8位。

例如：EAX为32位，AX为低16位（0-15位），AL是最低8位（0-7位），AH是次低8位（8-15位）

![img/binary](img/2021-10-04%2015-26-55屏幕截图.png)


## 5.4 汇编指令
`mov dst, src`mov指令可以将数据移动到寄存器或者内存

`lea dst, src`lea是load effective address的缩写，用来将一个内存地址赋给目的操作数。例如：`lea eax,[ebx+8]`就是将ebx+8的值给eax，实际上其和`mov eax,ebx+8`是等价的

`add dst, val/src`加法

`sub dst, val/src`减法。sub指令会修改两个重要的标志位：ZF和CF。如果结果是0，则ZF置1；如果dst比val/src要小，则CF被置1。

`inc dst`dst中的值+1

`dec dst`dst中的值-1

乘法和除法比较特殊，需要预先规定存储被乘数、被除数的结果的寄存器：

`mul val`乘法，其中这个val是乘数

`div val`除法，其中这个val是除数

mul或者div指令操作的寄存器一般会在之前许多条指令的地方被赋值，因此可能需要在程序上下文中来寻找被乘数和被除数。

![mul](./img/mul_div.png)
对于乘法指令，结果存放在EDX:EAX中，其中EDX存放高32位，EAX存放低32位，也就是**EDX:EAX = EAX * val**；对于除法指令，被除数存放在EDX:EAX中，除法结果的整数部分放在EAX中，余数部分放在EDX中，也就是**EAX * val + EDX = EDX:EAX**

逻辑运算符：OR（或），AND（与），XOR（异或）可以对源操作数和目的操作数进行相应的逻辑操作，并将结果保存在目的操作数中。

shr（向右）和shl（向左）指令用于对寄存器做位移操作

循环位移指令ror（向右）和rol（向左）与移位指令类似，但移出的那一位会被填到另一端空出来的位上。

nop指令：什么操作都不需要做，他的机器码是：0x90。其实这个指令实际上应该是`xchg eax`，把eax和自身交换，其实也就是什么用都没有。

## 5.5 栈操作
栈是一种后入先出的数据存储结构（向低地址增长），函数的参数、局部变量、流控制结构等被存储在栈中

* ESP：指向栈顶的内存地址
* EBP：指向栈底的内存地址
* PUSH：将数据压入栈顶
* POP：从栈顶取出数据

函数调用关于栈帧的操作流程
1. 参数入栈（从右向左）
2. 返回地址入栈
3. 栈帧切换
   1. EBP入栈
   2. 抬高ESP（也就是给局部变量开辟空间）

最常见的条件指令是：test和cmp。

test指令和and指令的功能一样，但是不会修改使用的操作数，只设置标志位

cmp指令和sub指令功能一样，但是不修改操作数，只设置标志位

![cmp](img/2021-10-04%2016-28-50屏幕截图.png)

分支指令（可以控制CPU指令的执行顺序，类似于IF语句）
* `jz loc`当ZF=1，跳转到loc，也就是两个数相等时跳转
* `jnz loc`当ZF=0，跳转到loc，也就是不等时跳转
* `je loc`当等于条件发生的时候进行跳转（same as jz）
* `jne loc`不等于条件发生的时候进行跳转（same as jnz）
* `jg loc`有符号的条件跳转，当dst > src时会进行跳转
* `jge loc`有符号比较，dst >= src的时候进行跳转
* `ja loc`无符号数的比较，dst > src跳转
* `jae loc`无符号数比较，dst >= src跳转
* `jl loc`有符号比较，dst < src跳转
* `jle loc`有符号比较，dst <= src跳转
* `jb loc`无符号比较，dst < src 跳转
* `jbe loc`无符号比较，dst <= src跳转
* `jo loc`OF标志位为1时跳转
* `js loc`SF标志位为1时跳转
* `jecxz loc`ECX为0时跳转（也就是循环的次数到了以后进行跳转）

重复操作指令：是对数据缓冲区操作的指令。数据缓冲区通常是一个字节数组的形式，也可以是单字或者双字。在x86体系下，使用重复的前缀来做多字节操作。`rep`指令会增加ESI和EDI这两个偏移，减少ECX寄存器。rep前缀会不断重复，直至ECX=0.

`repe/repz`和`repne/repnz`前缀则不断重复，直至ECX=0或直至ZF=1或0。

![rep](img/2021-10-04%2016-45-44屏幕截图.png)
